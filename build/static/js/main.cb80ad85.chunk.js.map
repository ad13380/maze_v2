{"version":3,"sources":["components/Grid/Node/Node.jsx","components/Grid/Grid.jsx","components/Button/Button.jsx","components/Error/Error.jsx","components/Counter/Counter.jsx","components/Title/Title.jsx","models/algorithms/dijkstra.js","hooks/useInitialGrid.jsx","hooks/useNewStartFinish.jsx","hooks/useClearVisitedNodes.jsx","hooks/useSetWallNode.jsx","containers/PathFindingVisualizer.jsx","hooks/useSetDragNode.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","type","isStart","isFinish","handleMouseDown","handleMouseEnter","handleMouseUp","row","col","nodeDrag","className","nodeClass","nodeType","getNodeClass","onMouseDown","onMouseEnter","onMouseUp","Grid","grid","map","rowIndex","key","node","Button","onClick","handleOnClick","disabled","onDisable","children","Error","Counter","isPathClear","visitedNodesInOrder","length","shortestPathNodesInOrder","Title","dijkstra","startNode","finishNode","distance","unvisitedNodes","reduce","acc","val","concat","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","push","updateUnvisitedNeighbours","sort","nodeA","nodeB","neighbours","filter","neighbour","getUnvisitedNeighbours","forEach","previousNode","shortestPath","shortestPathNodes","currentNode","unshift","_","require","PathFindingVisualizer","useState","setGrid","startNodeLoc","setStartNodeLoc","finishNodeLoc","setFinishNodeLoc","isAnimating","setIsAnimating","isSolvable","setIsSolvable","isMousePressed","setIsMousePressed","isDragging","setNodeDrag","setIsPathClear","setVisitedNodesInOrder","setShortestPathNodesInOrder","createNodeProps","gridRows","gridCols","initalGrid","currentRow","useInitialGrid","getInitialGrid","nodeLoc","newNodeLoc","dragType","newRow","newCol","updatedGrid","cloneDeep","getNewStartFinish","visitedNodes","getClearVisitedNodes","getSetWallNode","updatedNodeDrag","getSetDragNode","useEffect","initialGrid","a","animate","asyncAnimate","handleRunAlgorithm","startDraggingNode","endDraggingNode","endNodeLoc","charAt","toUpperCase","slice","nodeArray","delay","i","Promise","resolve","intervalID","setInterval","clearInterval","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"oXAyDeA,G,MAtDF,SAACC,GAAW,IAErBC,EASED,EATFC,KACAC,EAQEF,EARFE,QACAC,EAOEH,EAPFG,SACAC,EAMEJ,EANFI,gBACAC,EAKEL,EALFK,iBACAC,EAIEN,EAJFM,cACAC,EAGEP,EAHFO,IACAC,EAEER,EAFFQ,IACAC,EACET,EADFS,SAkCF,OACE,yBACEC,UAhCiB,WACnB,IAAIC,EAAY,QAEhB,OAAQF,EAASG,UACf,IAAK,QACHD,GAAa,cACb,MACF,IAAK,SACHA,GAAa,eAIjB,GAAIT,EACF,OAAQS,EAAa,aAChB,GAAIR,EACT,OAAQQ,EAAa,cAGvB,OAAQV,GACN,IAAK,OACH,OAAQU,EAAa,qBACvB,IAAK,UACH,OAAQA,EAAa,eACvB,IAAK,OACH,OAAQA,EAAa,YACvB,QACE,OAAQA,EAAa,cAMZE,GACXC,YAAa,kBAAMV,EAAgBG,EAAKC,IACxCO,aAAc,kBAAMV,EAAiBE,EAAKC,IAC1CQ,UAAW,kBAAMV,EAAcC,EAAKC,QClB3BS,G,MA9BF,SAACjB,GACZ,OACE,yBAAKU,UAAU,QACZV,EAAMkB,KAAKC,KAAI,SAACZ,EAAKa,GACpB,OACE,yBAAKC,IAAKD,GACPb,EAAIY,KAAI,SAACG,GAAU,IACVf,EAAgDe,EAAhDf,IAAKC,EAA2Cc,EAA3Cd,IAAKP,EAAsCqB,EAAtCrB,KAAMC,EAAgCoB,EAAhCpB,QAASC,EAAuBmB,EAAvBnB,SAAUM,EAAaa,EAAbb,SAC3C,OACE,kBAAC,EAAD,CACEY,IAAG,eAAUd,EAAV,YAAiBC,GACpBD,IAAKA,EACLC,IAAKA,EACLP,KAAMA,EACNC,QAASA,EACTC,SAAUA,EACVC,gBAAiBJ,EAAMI,gBACvBC,iBAAkBL,EAAMK,iBACxBC,cAAeN,EAAMM,cACrBG,SAAUA,cCRbc,G,MAZA,SAACvB,GACd,OACE,4BACEU,UAAW,sCACXc,QAASxB,EAAMyB,cACfC,SAAU1B,EAAM2B,WAEf3B,EAAM4B,YCMEC,G,MAbD,WACZ,OACE,yBAAKnB,UAAU,mBACb,yBAAKA,UAAU,iBAAf,6BACA,yBAAKA,UAAU,cAAf,iFAEQ,6BAFR,2CCaSoB,G,MAjBC,SAAC9B,GACf,OACE,yBAAKU,UAAU,mBACb,yBAAKA,UAAU,mBACb,yBAAKA,UAAU,iBAAf,kBACiB,6BADjB,wBAIA,yBAAKA,UAAU,mBACZV,EAAM+B,YAAc,IAAM/B,EAAMgC,oBAAoBC,OADvD,IAC+D,6BAC5DjC,EAAM+B,YAAc,IAAM/B,EAAMkC,yBAAyBD,YCNrDE,G,MAJD,WACZ,OAAO,yBAAKzB,UAAU,mBAAf,qBCJF,SAAS0B,EAASlB,EAAMmB,EAAWC,GACxC,IAAMN,EAAsB,GAC5BK,EAAUE,SAAW,EAGrB,IAFA,IAAMC,EAgBR,SAAqBtB,GACnB,OAAOA,EAAKuB,QAAO,SAACC,EAAKC,GAAN,OAAcD,EAAIE,OAAOD,MAjBrBE,CAAY3B,GAE1BsB,EAAeP,QAAQ,CAC9Ba,EAAoBN,GACpB,IAAMO,EAAcP,EAAeQ,QACnC,GAAyB,SAArBD,EAAY9C,KAAhB,CAEA,GAAI8C,EAAYR,WAAaU,IAAU,MAAO,EAAC,GAI/C,GAFAF,EAAY9C,KAAO,UACnB+B,EAAoBkB,KAAKH,GACrBA,IAAgBT,EAAY,OAAON,EACvCmB,EAA0BJ,EAAa7B,KAQ3C,SAAS4B,EAAoBN,GAC3BA,EAAeY,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMd,SAAWe,EAAMf,YAG/D,SAASY,EAA0B7B,EAAMJ,IAQzC,SAAgCI,EAAMJ,GACpC,IAAMqC,EAAa,GACX/C,EAAac,EAAbd,IAAKD,EAAQe,EAARf,IACTA,EAAM,GAAGgD,EAAWL,KAAKhC,EAAKX,EAAM,GAAGC,IACvCD,EAAMW,EAAKe,OAAS,GAAGsB,EAAWL,KAAKhC,EAAKX,EAAM,GAAGC,IACrDA,EAAM,GAAG+C,EAAWL,KAAKhC,EAAKX,GAAKC,EAAM,IACzCA,EAAMU,EAAK,GAAGe,OAAS,GAAGsB,EAAWL,KAAKhC,EAAKX,GAAKC,EAAM,IAC9D,OAAO+C,EAAWC,QAAO,SAACC,GAAD,MAAkC,YAAnBA,EAAUxD,SAdtByD,CAAuBpC,EAAMJ,GACrCyC,SAAQ,SAACF,GAC3BA,EAAUlB,SAAWjB,EAAKiB,SAAW,EACrCkB,EAAUG,aAAetC,KActB,SAASuC,EAAavB,GAG3B,IAFA,IAAMwB,EAAoB,GACtBC,EAAczB,EACK,OAAhByB,GACLD,EAAkBE,QAAQD,GAC1BA,EAAcA,EAAYH,aAE5B,OAAOE,ECpDF,ICAHG,EAAIC,EAAQ,GCAZD,EAAIC,EAAQ,GCAZD,EAAIC,EAAQ,GCYZD,EAAIC,EAAQ,GAwLDC,EAnLe,WAAO,IAAD,EACVC,mBAAS,IADC,mBAC3BlD,EAD2B,KACrBmD,EADqB,OAEMD,mBAAS,CAAE7D,IAAK,GAAIC,IAAK,KAF/B,mBAE3B8D,EAF2B,KAEbC,EAFa,OAGQH,mBAAS,CAAE7D,IAAK,GAAIC,IAAK,KAHjC,mBAG3BgE,EAH2B,KAGZC,EAHY,OAIIL,oBAAS,GAJb,mBAI3BM,EAJ2B,KAIdC,EAJc,OAKEP,oBAAS,GALX,mBAK3BQ,EAL2B,KAKfC,EALe,OAMUT,oBAAS,GANnB,mBAM3BU,EAN2B,KAMXC,EANW,OAOFX,mBAAS,CAAEY,YAAY,EAAOpE,SAAU,KAPtC,mBAO3BH,EAP2B,KAOjBwE,EAPiB,OAQIb,oBAAS,GARb,mBAQ3BrC,EAR2B,KAQdmD,EARc,OASoBd,mBAAS,IAT7B,mBAS3BpC,EAT2B,KASNmD,EATM,OAU8Bf,mBAAS,IAVvC,oBAU3BlC,GAV2B,MAUDkD,GAVC,SJjBN,WAC5B,IAoBMC,EAAkB,SACtB7E,EACAD,EACA+D,EACAE,EACA/D,GALsB,MAMlB,CACJD,MACAD,MACAL,QAASK,IAAQ+D,EAAa/D,KAAOC,IAAQ8D,EAAa9D,IAC1DL,SAAUI,IAAQiE,EAAcjE,KAAOC,IAAQgE,EAAchE,IAC7D+B,SAAUU,IACVhD,KAAM,GACN2D,aAAc,KACdnD,SAAUA,IAGZ,MAAO,CArCgB,SACrB6E,EACAC,EACAjB,EACAE,EACA/D,GAGA,IADA,IAAM+E,EAAa,GACVjF,EAAM,EAAGA,EAAM+E,EAAU/E,IAAO,CAEvC,IADA,IAAMkF,EAAa,GACVjF,EAAM,EAAGA,EAAM+E,EAAU/E,IAChCiF,EAAWvC,KACTmC,EAAgB7E,EAAKD,EAAK+D,EAAcE,EAAe/D,IAG3D+E,EAAWtC,KAAKuC,GAElB,OAAOD,IIWgBE,GAAlBC,GAZ2B,wBHF3B,CAZmB,SAACzE,EAAM0E,EAASC,EAAYC,GACpD,GAAIF,EAAQrF,MAAQsF,EAAWtF,KAAOqF,EAAQpF,MAAQqF,EAAWrF,IAAjE,CADiE,IAGzDD,EAAaqF,EAAbrF,IAAKC,EAAQoF,EAARpF,IACLuF,EAAmBF,EAAnBE,OAAQC,EAAWH,EAAXG,OACVC,EAAchC,EAAEiC,UAAUhF,GAKhC,OAJA+E,EAAY1F,GAAKC,GAAKsF,IAAY,EAClCG,EAAYF,GAAQC,GAAQF,IAAY,EACxCG,EAAY1F,GAAKC,GAAKP,KAAO,GAC7BgG,EAAYF,GAAQC,GAAQ/F,KAAO,GAC5BgG,KGiBFE,GAb2B,wBFC3B,CAfsB,SAACjF,EAAMkF,GAClC,IAAKA,EAAa,GAAI,OAAOlF,EAE7B,IAAM+E,EAAchC,EAAEiC,UAAUhF,GAUhC,OATAkF,EAAazC,SAAQ,SAACrC,GAAU,IACtBf,EAAae,EAAbf,IAAKC,EAAQc,EAARd,IAEoB,YAA/ByF,EAAY1F,GAAKC,GAAKP,MACS,SAA/BgG,EAAY1F,GAAKC,GAAKP,OAEtBgG,EAAY1F,GAAKC,GAAKP,KAAO,OAG1BgG,IEeFI,GAd2B,wBDL3B,CATgB,SAACnF,EAAMX,EAAKC,GACjC,IAAMyF,EAAchC,EAAEiC,UAAUhF,GAC1BI,EAAO2E,EAAY1F,GAAKC,GAK9B,OAJKc,EAAKpB,SAAWoB,EAAKnB,WACxBmB,EAAKrB,KAAqB,SAAdqB,EAAKrB,KAAkB,GAAK,OACxCgG,EAAY1F,GAAKC,GAAOc,GAEnB2E,ICsBFK,GAf2B,wBCP3B,CATgB,SAACpF,EAAMqF,GAC5B,OAAOrF,EAAKC,KAAI,SAACZ,GACf,OAAOA,EAAIY,KAAI,SAACG,GAEd,OADAA,EAAKb,SAAW8F,EACTjF,UD4BNkF,GAhB2B,qBAkBlCC,qBAAU,WACR,IAAMC,EAAcf,GAtBN,GACA,GAwBZrB,EACAE,EACA/D,GAEF4D,EAAQqC,KACP,IAEHD,qBAAU,WACR,GAAKzE,EAAoBC,QAAWC,GAAyBD,OAC7D,GAAKD,EAAoB,GAAzB,CAKA6C,GAAc,GACd,IAAMoB,EAAchC,EAAEiC,UAAUhF,IACd,uCAAG,sBAAAyF,EAAA,6DACnBhC,GAAe,GADI,SAEbiC,GAAQX,EAAajE,EAAqB,UAAW,IAFxC,uBAGb4E,GAAQX,EAAa/D,GAA0B,OAAQ,IAH1C,OAInByC,GAAe,GAJI,2CAAH,qDAMlBkC,QAZEhC,GAAc,KAaf,CAAC7C,EAAqBE,KAEzB,IAmCM4E,GAAkB,uCAAG,gCAAAH,EAAA,sDACnBV,EAAchC,EAAEiC,UAAUhF,GAC1BmB,EAAY4D,EAAY3B,EAAa/D,KAAK+D,EAAa9D,KACvD8B,EAAa2D,EAAYzB,EAAcjE,KAAKiE,EAAchE,KAChE2E,EAAuB/C,EAAS6D,EAAa5D,EAAWC,IACxD8C,GAA4BvB,EAAavB,IALhB,2CAAH,qDA0BlByE,GAAoB,SAACnG,GACzBqE,EAAY,CAAED,YAAY,EAAMpE,SAAUA,IAC1C,IAAMqF,EAAcO,GAAetF,EAAM,CACvC8D,YAAY,EACZpE,SAAUA,IAEZyD,EAAQ4B,IAGJe,GAAkB,SAACzG,EAAKC,EAAKI,EAAUqG,GAC3C,IAAIhB,EAAcE,GAChBjF,EACA+F,EACA,CAAElB,OAAQxF,EAAKyF,OAAQxF,GAHU,YAI5BI,EAASsG,OAAO,GAAGC,cAAgBvG,EAASwG,MAAM,KAEzDnB,EAAcO,GAAeP,EAAa,CACxCjB,YAAY,EACZpE,SAAU,KAEZyD,EAAQ4B,IAGJW,GAAO,uCAAG,WAAOX,EAAaoB,EAAWpH,EAAMqH,GAArC,eAAAX,EAAA,6DACdzB,GAAe,GACXqC,EAAI,EAFM,SAGD,IAAIC,SAAQ,SAACC,GACxB,IAAMC,EAAaC,aAAY,WAAO,IAAD,EACdN,EAAUE,GAAvBhH,EAD2B,EAC3BA,IAAKC,EADsB,EACtBA,IACbyF,EAAY1F,GAAKC,GAAKP,KAAOA,EAC7BoE,EAAQ,YAAI4B,MACNsB,IAAMF,EAAUpF,SACpB2F,cAAcF,GACdD,OAEDH,MAZS,mFAAH,4DAgBb,OACE,oCACE,kBAAC,EAAD,MACC1C,EACC,kBAAC,EAAD,CACE7C,YAAaA,EACbC,oBAAqBA,EACrBE,yBAA0BA,KAG5B,kBAAC,EAAD,MAEF,kBAAC,EAAD,CAAQT,cArEc,WACxByD,GAAe,GACf,IAAMe,EAAcN,GA/FN,GACA,GAiGZrB,EACAE,EACA/D,GAEF4D,EAAQ4B,IA4DoCtE,UAAW+C,GAArD,gBAGA,kBAAC,EAAD,CAAQjD,cA5De,WACzByD,GAAe,GACf,IAAMe,EAAcI,GAAqBnF,EAAMc,GAC/CqC,EAAQ4B,IAyDqCtE,UAAW+C,GAAtD,cAGA,kBAAC,EAAD,CAAQjD,cAAeqF,GAAoBnF,WAAYI,GAAvD,iBAGA,6BACA,kBAAC,EAAD,CACEb,KAAMA,EACNd,gBA5HkB,SAACG,EAAKC,GAC5B,IAAIkE,IAAejE,EAASuE,WAC5B,GAAI9D,EAAKX,GAAKC,GAAKN,QACjB6G,GAAkB,cAGpB,GAAI7F,EAAKX,GAAKC,GAAKL,SACjB4G,GAAkB,cADpB,CAIA,IAAMd,EAAcK,GAAepF,EAAMX,EAAKC,GAC9CuE,GAAkB,GAClBV,EAAQ4B,KAiHJ5F,iBA9GmB,SAACE,EAAKC,GAC7B,GAA4B,SAAxBU,EAAKX,GAAKC,GAAKP,MAAoB6E,EAAvC,CACA,IAAMmB,EAAcK,GAAepF,EAAMX,EAAKC,GAC9C6D,EAAQ4B,KA4GJ3F,cAzGgB,SAACC,EAAKC,GACtBC,EAASuE,aACe,UAAtBvE,EAASG,UACX2D,EAAgB,CAAEhE,IAAKA,EAAKC,IAAKA,IACjCwG,GAAgBzG,EAAKC,EAAK,QAAS8D,KAEnCG,EAAiB,CAAElE,IAAKA,EAAKC,IAAKA,IAClCwG,GAAgBzG,EAAKC,EAAK,SAAUgE,IAEtCS,EAAY,CAAED,YAAY,EAAOpE,SAAU,MAE7CmE,GAAkB,QEpFP8C,G,MARH,WACV,OACE,yBAAKnH,UAAU,OACb,kBAAC,EAAD,SCKcoH,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.cb80ad85.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Node.css\";\n\nconst Node = (props) => {\n  const {\n    type,\n    isStart,\n    isFinish,\n    handleMouseDown,\n    handleMouseEnter,\n    handleMouseUp,\n    row,\n    col,\n    nodeDrag,\n  } = props;\n\n  // converting this to a reducer causes a noticable hit in animation performance\n  const getNodeClass = () => {\n    let nodeClass = \"node \";\n\n    switch (nodeDrag.nodeType) {\n      case \"start\":\n        nodeClass += \"start-drag \";\n        break;\n      case \"finish\":\n        nodeClass += \"finish-drag \";\n        break;\n    }\n\n    if (isStart) {\n      return (nodeClass += \"node-start\");\n    } else if (isFinish) {\n      return (nodeClass += \"node-finish\");\n    }\n\n    switch (type) {\n      case \"path\":\n        return (nodeClass += \"node-shortest-path\");\n      case \"visited\":\n        return (nodeClass += \"node-visited\");\n      case \"wall\":\n        return (nodeClass += \"node-wall\");\n      default:\n        return (nodeClass += \"node-empty\");\n    }\n  };\n\n  return (\n    <div\n      className={getNodeClass()}\n      onMouseDown={() => handleMouseDown(row, col)}\n      onMouseEnter={() => handleMouseEnter(row, col)}\n      onMouseUp={() => handleMouseUp(row, col)}\n    ></div>\n  );\n};\n\nexport default Node;\n","import React from \"react\";\nimport Node from \"./Node/Node\";\nimport \"./Grid.css\";\n\nconst Grid = (props) => {\n  return (\n    <div className=\"grid\">\n      {props.grid.map((row, rowIndex) => {\n        return (\n          <div key={rowIndex}>\n            {row.map((node) => {\n              const { row, col, type, isStart, isFinish, nodeDrag } = node;\n              return (\n                <Node\n                  key={`node-${row}-${col}`}\n                  row={row}\n                  col={col}\n                  type={type}\n                  isStart={isStart}\n                  isFinish={isFinish}\n                  handleMouseDown={props.handleMouseDown}\n                  handleMouseEnter={props.handleMouseEnter}\n                  handleMouseUp={props.handleMouseUp}\n                  nodeDrag={nodeDrag}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nexport default Grid;\n","import React from \"react\";\nimport \"./Button.css\";\n\nconst Button = (props) => {\n  return (\n    <button\n      className={\"btn btn-outline-dark button-styling\"}\n      onClick={props.handleOnClick}\n      disabled={props.onDisable}\n    >\n      {props.children}\n    </button>\n  );\n};\n\nexport default Button;\n","import React from \"react\";\nimport \"./Error.css\";\n\nconst Error = () => {\n  return (\n    <div className=\"error-container\">\n      <div className=\"error-message\">This maze can't be solved</div>\n      <div className=\"error-hint\">\n        Hint: click on an existing wall node to remove it, or drag and drop the\n        start <br />\n        and end nodes to different locations\n      </div>\n    </div>\n  );\n};\n\nexport default Error;\n","import React from \"react\";\nimport \"./Counter.css\";\n\nconst Counter = (props) => {\n  return (\n    <div className=\"outer-container\">\n      <div className=\"inner-container\">\n        <div className=\"counter-title\">\n          Visited Nodes: <br />\n          Shortest Path Nodes:\n        </div>\n        <div className=\"counter-numbers\">\n          {props.isPathClear ? \"0\" : props.visitedNodesInOrder.length} <br />\n          {props.isPathClear ? \"0\" : props.shortestPathNodesInOrder.length}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Counter;\n","import React from \"react\";\nimport \"./Title.css\";\n\nconst Title = () => {\n  return <div className=\"title-container\">Maze Pathfinder</div>;\n};\n\nexport default Title;\n","export function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.type === \"wall\") continue;\n\n    if (closestNode.distance === Infinity) return [false];\n\n    closestNode.type = \"visited\";\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\nfunction getAllNodes(grid) {\n  return grid.reduce((acc, val) => acc.concat(val));\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n  unvisitedNeighbours.forEach((neighbour) => {\n    neighbour.distance = node.distance + 1;\n    neighbour.previousNode = node;\n  });\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const neighbours = [];\n  const { col, row } = node;\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  return neighbours.filter((neighbour) => neighbour.type !== \"visited\");\n}\n\nexport function shortestPath(finishNode) {\n  const shortestPathNodes = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    shortestPathNodes.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return shortestPathNodes;\n}\n","export const useInitialGrid = () => {\n  const getInitialGrid = (\n    gridRows,\n    gridCols,\n    startNodeLoc,\n    finishNodeLoc,\n    nodeDrag\n  ) => {\n    const initalGrid = [];\n    for (let row = 0; row < gridRows; row++) {\n      const currentRow = [];\n      for (let col = 0; col < gridCols; col++) {\n        currentRow.push(\n          createNodeProps(col, row, startNodeLoc, finishNodeLoc, nodeDrag)\n        );\n      }\n      initalGrid.push(currentRow);\n    }\n    return initalGrid;\n  };\n\n  const createNodeProps = (\n    col,\n    row,\n    startNodeLoc,\n    finishNodeLoc,\n    nodeDrag\n  ) => ({\n    col,\n    row,\n    isStart: row === startNodeLoc.row && col === startNodeLoc.col,\n    isFinish: row === finishNodeLoc.row && col === finishNodeLoc.col,\n    distance: Infinity,\n    type: \"\",\n    previousNode: null,\n    nodeDrag: nodeDrag,\n  });\n\n  return [getInitialGrid];\n};\n","var _ = require(\"lodash\");\n\nexport const useNewStartFinish = () => {\n  const getNewStartFinish = (grid, nodeLoc, newNodeLoc, dragType) => {\n    if (nodeLoc.row === newNodeLoc.row && nodeLoc.col === newNodeLoc.col)\n      return;\n    const { row, col } = nodeLoc;\n    const { newRow, newCol } = newNodeLoc;\n    const updatedGrid = _.cloneDeep(grid);\n    updatedGrid[row][col][dragType] = false;\n    updatedGrid[newRow][newCol][dragType] = true;\n    updatedGrid[row][col].type = \"\";\n    updatedGrid[newRow][newCol].type = \"\";\n    return updatedGrid;\n  };\n  return [getNewStartFinish];\n};\n","var _ = require(\"lodash\");\n\nexport const useClearVisitedNodes = () => {\n  const getClearVisitedNodes = (grid, visitedNodes) => {\n    if (!visitedNodes[0]) return grid;\n\n    const updatedGrid = _.cloneDeep(grid);\n    visitedNodes.forEach((node) => {\n      const { row, col } = node;\n      if (\n        updatedGrid[row][col].type === \"visited\" ||\n        updatedGrid[row][col].type === \"path\"\n      ) {\n        updatedGrid[row][col].type = \"\";\n      }\n    });\n    return updatedGrid;\n  };\n  return [getClearVisitedNodes];\n};\n","var _ = require(\"lodash\");\n\nexport const useSetWallNode = () => {\n  const getSetWallNode = (grid, row, col) => {\n    const updatedGrid = _.cloneDeep(grid);\n    const node = updatedGrid[row][col];\n    if (!node.isStart & !node.isFinish) {\n      node.type = node.type === \"wall\" ? \"\" : \"wall\";\n      updatedGrid[row][col] = node;\n    }\n    return updatedGrid;\n  };\n  return [getSetWallNode];\n};\n","import React, { useState, useEffect } from \"react\";\nimport Grid from \"../components/Grid/Grid\";\nimport Button from \"../components/Button/Button\";\nimport Error from \"../components/Error/Error\";\nimport Counter from \"../components/Counter/Counter\";\nimport Title from \"../components/Title/Title\";\nimport { dijkstra, shortestPath } from \"../models/algorithms/dijkstra\";\nimport { useInitialGrid } from \"../hooks/useInitialGrid\";\nimport { useNewStartFinish } from \"../hooks/useNewStartFinish\";\nimport { useClearVisitedNodes } from \"../hooks/useClearVisitedNodes\";\nimport { useSetWallNode } from \"../hooks/useSetWallNode\";\nimport { useSetDragNode } from \"../hooks/useSetDragNode\";\nvar _ = require(\"lodash\");\n\nconst GRID_ROWS = 20;\nconst GRID_COLS = 40;\n\nconst PathFindingVisualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const [startNodeLoc, setStartNodeLoc] = useState({ row: 10, col: 12 });\n  const [finishNodeLoc, setFinishNodeLoc] = useState({ row: 10, col: 28 });\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [isSolvable, setIsSolvable] = useState(true);\n  const [isMousePressed, setIsMousePressed] = useState(false);\n  const [nodeDrag, setNodeDrag] = useState({ isDragging: false, nodeType: \"\" });\n  const [isPathClear, setIsPathClear] = useState(true);\n  const [visitedNodesInOrder, setVisitedNodesInOrder] = useState([]);\n  const [shortestPathNodesInOrder, setShortestPathNodesInOrder] = useState([]);\n\n  const [getInitialGrid] = useInitialGrid();\n  const [getNewStartFinish] = useNewStartFinish();\n  const [getClearVisitedNodes] = useClearVisitedNodes();\n  const [getSetWallNode] = useSetWallNode();\n  const [getSetDragNode] = useSetDragNode();\n\n  useEffect(() => {\n    const initialGrid = getInitialGrid(\n      GRID_ROWS,\n      GRID_COLS,\n      startNodeLoc,\n      finishNodeLoc,\n      nodeDrag\n    );\n    setGrid(initialGrid);\n  }, []);\n\n  useEffect(() => {\n    if (!visitedNodesInOrder.length || !shortestPathNodesInOrder.length) return;\n    if (!visitedNodesInOrder[0]) {\n      setIsSolvable(false);\n      return;\n    }\n\n    setIsSolvable(true);\n    const updatedGrid = _.cloneDeep(grid);\n    const asyncAnimate = async () => {\n      setIsAnimating(true);\n      await animate(updatedGrid, visitedNodesInOrder, \"visited\", 20);\n      await animate(updatedGrid, shortestPathNodesInOrder, \"path\", 70);\n      setIsAnimating(false);\n    };\n    asyncAnimate();\n  }, [visitedNodesInOrder, shortestPathNodesInOrder]);\n\n  const handleMouseDown = (row, col) => {\n    if (isAnimating || nodeDrag.isDragging) return;\n    if (grid[row][col].isStart) {\n      startDraggingNode(\"start\");\n      return;\n    }\n    if (grid[row][col].isFinish) {\n      startDraggingNode(\"finish\");\n      return;\n    }\n    const updatedGrid = getSetWallNode(grid, row, col);\n    setIsMousePressed(true);\n    setGrid(updatedGrid);\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (grid[row][col].type === \"wall\" || !isMousePressed) return;\n    const updatedGrid = getSetWallNode(grid, row, col);\n    setGrid(updatedGrid);\n  };\n\n  const handleMouseUp = (row, col) => {\n    if (nodeDrag.isDragging) {\n      if (nodeDrag.nodeType === \"start\") {\n        setStartNodeLoc({ row: row, col: col });\n        endDraggingNode(row, col, \"start\", startNodeLoc);\n      } else {\n        setFinishNodeLoc({ row: row, col: col });\n        endDraggingNode(row, col, \"finish\", finishNodeLoc);\n      }\n      setNodeDrag({ isDragging: false, nodeType: \"\" });\n    }\n    setIsMousePressed(false);\n  };\n\n  const handleRunAlgorithm = async () => {\n    const updatedGrid = _.cloneDeep(grid);\n    const startNode = updatedGrid[startNodeLoc.row][startNodeLoc.col];\n    const finishNode = updatedGrid[finishNodeLoc.row][finishNodeLoc.col];\n    setVisitedNodesInOrder(dijkstra(updatedGrid, startNode, finishNode));\n    setShortestPathNodesInOrder(shortestPath(finishNode));\n  };\n\n  const handleClearScreen = () => {\n    setIsPathClear(true);\n    const updatedGrid = getInitialGrid(\n      GRID_ROWS,\n      GRID_COLS,\n      startNodeLoc,\n      finishNodeLoc,\n      nodeDrag\n    );\n    setGrid(updatedGrid);\n  };\n\n  const handleClearVisited = () => {\n    setIsPathClear(true);\n    const updatedGrid = getClearVisitedNodes(grid, visitedNodesInOrder);\n    setGrid(updatedGrid);\n  };\n\n  const startDraggingNode = (nodeType) => {\n    setNodeDrag({ isDragging: true, nodeType: nodeType });\n    const updatedGrid = getSetDragNode(grid, {\n      isDragging: true,\n      nodeType: nodeType,\n    });\n    setGrid(updatedGrid);\n  };\n\n  const endDraggingNode = (row, col, nodeType, endNodeLoc) => {\n    let updatedGrid = getNewStartFinish(\n      grid,\n      endNodeLoc,\n      { newRow: row, newCol: col },\n      `is${nodeType.charAt(0).toUpperCase() + nodeType.slice(1)}`\n    );\n    updatedGrid = getSetDragNode(updatedGrid, {\n      isDragging: false,\n      nodeType: \"\",\n    });\n    setGrid(updatedGrid);\n  };\n\n  const animate = async (updatedGrid, nodeArray, type, delay) => {\n    setIsPathClear(false);\n    let i = 0;\n    return await new Promise((resolve) => {\n      const intervalID = setInterval(() => {\n        const { row, col } = nodeArray[i];\n        updatedGrid[row][col].type = type;\n        setGrid([...updatedGrid]);\n        if (++i === nodeArray.length) {\n          clearInterval(intervalID);\n          resolve();\n        }\n      }, delay);\n    });\n  };\n\n  return (\n    <>\n      <Title />\n      {isSolvable ? (\n        <Counter\n          isPathClear={isPathClear}\n          visitedNodesInOrder={visitedNodesInOrder}\n          shortestPathNodesInOrder={shortestPathNodesInOrder}\n        />\n      ) : (\n        <Error />\n      )}\n      <Button handleOnClick={handleClearScreen} onDisable={isAnimating}>\n        Clear Screen\n      </Button>\n      <Button handleOnClick={handleClearVisited} onDisable={isAnimating}>\n        Clear Path\n      </Button>\n      <Button handleOnClick={handleRunAlgorithm} onDisable={!isPathClear}>\n        Run Algorithm\n      </Button>\n      <br />\n      <Grid\n        grid={grid}\n        handleMouseDown={handleMouseDown}\n        handleMouseEnter={handleMouseEnter}\n        handleMouseUp={handleMouseUp}\n      />\n    </>\n  );\n};\n\nexport default PathFindingVisualizer;\n","export const useSetDragNode = () => {\n  const getSetDragNode = (grid, updatedNodeDrag) => {\n    return grid.map((row) => {\n      return row.map((node) => {\n        node.nodeDrag = updatedNodeDrag;\n        return node;\n      });\n    });\n  };\n\n  return [getSetDragNode];\n};\n","import React from \"react\";\nimport PathFindingVisualizer from \"./containers/PathFindingVisualizer\";\nimport \"./App.css\";\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer />\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}